---
import { Image } from 'astro:assets';
import BaseLayout from '../../layouts/BaseLayout.astro';
import { SITE_DESCRIPTION, SITE_TITLE } from '../../consts';
import { currentlyPlaying } from '../../data/currently-playing';
import placeholder1 from '../../assets/blog-placeholder-1.jpg';
import placeholder2 from '../../assets/blog-placeholder-2.jpg';
import placeholder3 from '../../assets/blog-placeholder-3.jpg';
import placeholder4 from '../../assets/blog-placeholder-4.jpg';
import placeholder5 from '../../assets/blog-placeholder-5.jpg';
import reviewsIndexStylesHref from '../../styles/pages/reviews-index.css?url';
import { contentVisibilityOptions } from '../../utils/content';
import { getVisibleReviews } from '../../utils/reviews';

const realPosts = await getVisibleReviews(contentVisibilityOptions(import.meta.env.DEV));

type ReviewPost = (typeof realPosts)[number];
type MockReview = {
	id: string;
	mock: true;
	data: {
		title: string;
		description: string;
		pubDate: Date;
		heroImage?: typeof placeholder1;
		genres?: string[];
		platforms?: Array<{ name: string; played?: boolean }>;
		gotyYear?: number;
		blurb?: string;
		draft: boolean;
	};
};
type RenderablePost = ReviewPost | MockReview;

const mockPosts: MockReview[] = [
	{
		id: 'mock-ender-magnolia',
		mock: true,
		data: {
			title: 'ENDER MAGNOLIA: Bloom in the Mist',
			description: 'The metroidvania that finally started to click for me - mostly.',
			pubDate: new Date('2025-03-12'),
			heroImage: placeholder2,
			genres: ['Metroidvania', 'Action RPG'],
			platforms: [{ name: 'Steam', played: true }, { name: 'PS5' }],
			blurb: 'Great atmosphere, uneven momentum, but enough elegance to keep me in.',
			draft: false,
		},
	},
	{
		id: 'mock-rebirth',
		mock: true,
		data: {
			title: 'Final Fantasy VII Rebirth',
			description: 'A huge, messy, expensive game that wins on sincerity more than discipline.',
			pubDate: new Date('2025-01-28'),
			heroImage: placeholder4,
			genres: ['Action RPG', 'Open World'],
			platforms: [{ name: 'PS5', played: true }],
			blurb: 'A slower start than expected, but the production confidence carries it.',
			draft: false,
		},
	},
	{
		id: 'mock-demonschool',
		mock: true,
		data: {
			title: 'Demonschool',
			description: 'The tactical loop is repetitive in spots, but the cast keeps it alive.',
			pubDate: new Date('2025-02-09'),
			heroImage: placeholder3,
			genres: ['Strategy RPG', 'Turn-Based'],
			platforms: [{ name: 'Steam', played: true }],
			draft: false,
		},
	},
	{
		id: 'mock-lies-of-p',
		mock: true,
		data: {
			title: 'Lies of P',
			description: 'An impressively controlled soulslike with a few mechanical habits I never loved.',
			pubDate: new Date('2024-10-04'),
			heroImage: placeholder1,
			genres: ['Soulslike', 'Action RPG'],
			platforms: [{ name: 'Steam', played: true }, { name: 'PS5' }],
			draft: false,
		},
	},
	{
		id: 'mock-astro-bot',
		mock: true,
		data: {
			title: 'Astro Bot',
			description: 'A joyful platformer that understands pace better than most prestige games.',
			pubDate: new Date('2024-11-15'),
			heroImage: placeholder5,
			genres: ['Platformer', 'Action Adventure'],
			platforms: [{ name: 'PS5', played: true }],
			draft: false,
		},
	},
	{
		id: 'mock-p3r',
		mock: true,
		data: {
			title: 'Persona 3 Reload',
			description: 'Stylish and smoother to play, but still wrestling with the bones of the original.',
			pubDate: new Date('2024-08-21'),
			heroImage: placeholder3,
			genres: ['Turn-Based', 'RPG'],
			platforms: [{ name: 'Steam', played: true }, { name: 'PC Game Pass', played: true }],
			draft: false,
		},
	},
	{
		id: 'mock-erdtree',
		mock: true,
		data: {
			title: 'Elden Ring: Shadow of the Erdtree',
			description: 'Brilliant highs, exhausting lows, and no interest in compromise.',
			pubDate: new Date('2024-06-29'),
			heroImage: placeholder4,
			genres: ['Action RPG', 'Soulslike'],
			platforms: [{ name: 'Steam', played: true }],
			draft: false,
		},
	},
	{
		id: 'mock-bg3',
		mock: true,
		data: {
			title: "Baldur's Gate 3",
			description: 'Ambition in every direction, with enough friction to make the victories feel earned.',
			pubDate: new Date('2024-02-18'),
			heroImage: placeholder2,
			genres: ['CRPG', 'Turn-Based'],
			platforms: [{ name: 'PS5', played: true }, { name: 'Steam' }],
			draft: false,
		},
	},
	{
		id: 'mock-armored-core-vi',
		mock: true,
		data: {
			title: 'Armored Core VI: Fires of Rubicon',
			description: 'Precision, velocity, and mission design that actually respects your time.',
			pubDate: new Date('2023-12-03'),
			heroImage: placeholder5,
			genres: ['Action', 'Mech'],
			platforms: [{ name: 'Steam', played: true }],
			draft: false,
		},
	},
	{
		id: 'mock-starfield',
		mock: true,
		data: {
			title: 'Starfield',
			description: 'A game I admire more in memory than I did while actively playing it.',
			pubDate: new Date('2023-10-17'),
			heroImage: placeholder1,
			genres: ['RPG', 'Open World'],
			platforms: [{ name: 'Xbox Series X/S', played: true }, { name: 'PC Game Pass', played: true }],
			draft: false,
		},
	},
	{
		id: 'mock-ffxvi',
		mock: true,
		data: {
			title: 'Final Fantasy XVI',
			description: 'Spectacle-first storytelling with combat that takes too long to show its depth.',
			pubDate: new Date('2023-07-09'),
			heroImage: placeholder4,
			genres: ['Action RPG'],
			platforms: [{ name: 'PS5', played: true }],
			draft: true,
		},
	},
	{
		id: 'mock-pikmin-4',
		mock: true,
		data: {
			title: 'Pikmin 4',
			description: 'A strategy game that is at its best when it lets tiny disasters spiral.',
			pubDate: new Date('2023-08-04'),
			heroImage: placeholder2,
			genres: ['Strategy', 'Adventure'],
			platforms: [{ name: 'Switch', played: true }],
			draft: false,
		},
	},
	{
		id: 'mock-sea-of-stars',
		mock: true,
		data: {
			title: 'Sea of Stars',
			description: 'Beautiful craft, sharp pacing, and a story that never fully landed for me.',
			pubDate: new Date('2023-09-02'),
			heroImage: placeholder3,
			genres: ['Turn-Based', 'RPG'],
			platforms: [{ name: 'Steam', played: true }, { name: 'Switch' }],
			draft: false,
		},
	},
	{
		id: 'mock-triangle-strategy',
		mock: true,
		data: {
			title: 'Triangle Strategy',
			description: 'Long-winded, deliberate, and absolutely my kind of problem.',
			pubDate: new Date('2022-11-20'),
			heroImage: placeholder5,
			genres: ['Strategy RPG', 'Turn-Based'],
			platforms: [{ name: 'Switch', played: true }, { name: 'Steam' }],
			draft: false,
		},
	},
	{
		id: 'mock-kirby-forgotten-land',
		mock: true,
		data: {
			title: 'Kirby and the Forgotten Land',
			description: 'Playful, smartly scoped, and one of the easiest recommendations on this page.',
			pubDate: new Date('2022-04-14'),
			heroImage: placeholder1,
			genres: ['Action Platformer'],
			platforms: [{ name: 'Switch', played: true }],
			draft: false,
		},
	},
	{
		id: 'mock-vampire-survivors',
		mock: true,
		data: {
			title: 'Vampire Survivors',
			description: 'The ugliest timesink of 2022 and I mean that as a compliment.',
			pubDate: new Date('2022-12-01'),
			heroImage: placeholder4,
			genres: ['Roguelite', 'Action'],
			platforms: [{ name: 'Steam', played: true }, { name: 'Xbox Series X/S' }],
			draft: false,
		},
	},
	{
		id: 'mock-chained-echoes',
		mock: true,
		data: {
			title: 'Chained Echoes',
			description: 'Ambitious indie JRPG design with systems that keep tightening as it goes.',
			pubDate: new Date('2022-12-18'),
			heroImage: placeholder2,
			genres: ['Turn-Based', 'JRPG'],
			platforms: [{ name: 'Steam', played: true }, { name: 'Game Pass' }],
			draft: false,
		},
	},
];

const isMockPost = (post: RenderablePost): post is MockReview => 'mock' in post;
const getPostHref = (post: RenderablePost) => (isMockPost(post) ? undefined : `/reviews/${post.id}/`);

const posts: RenderablePost[] = [...realPosts, ...mockPosts].sort(
	(a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf(),
);

const featuredPosts = realPosts.slice(0, 3) as RenderablePost[];
const featuredIds = new Set(featuredPosts.map((post) => post.id));
const archivePosts = posts.filter((post) => !featuredIds.has(post.id));

const getGenresLabel = (post: RenderablePost, count = 2) =>
	post.data.genres?.slice(0, count).join(' / ') ?? 'Review';

const getFeaturedKicker = (post: RenderablePost) =>
	post.data.gotyYear ? `${getGenresLabel(post)} / ${post.data.gotyYear} GOTY` : getGenresLabel(post);

const getPlayedPlatforms = (post: RenderablePost, limit = 2) =>
	post.data.platforms?.filter((platform) => platform.played).map((platform) => platform.name).slice(0, limit) ??
	[];

const getPreferredPlatform = (post: RenderablePost) =>
	getPlayedPlatforms(post, 1)[0] ?? post.data.platforms?.[0]?.name ?? '';

const PLATFORM_FILTER_GROUPS = ['PC', 'PlayStation', 'Switch', 'Xbox'] as const;
type PlatformFilterGroup = (typeof PLATFORM_FILTER_GROUPS)[number];

const classifyPlatformGroup = (platformName: string): PlatformFilterGroup | null => {
	const normalized = platformName.toLowerCase();
	if (
		normalized.includes('steam') ||
		normalized.includes('gog') ||
		normalized.includes('pc game pass') ||
		normalized === 'pc' ||
		normalized.startsWith('pc ')
	) {
		return 'PC';
	}
	if (normalized.includes('playstation') || normalized.startsWith('ps')) {
		return 'PlayStation';
	}
	if (normalized.includes('switch')) {
		return 'Switch';
	}
	if (normalized.includes('xbox') || normalized === 'game pass') {
		return 'Xbox';
	}
	return null;
};

const getFilterPlatforms = (post: RenderablePost) =>
	Array.from(
		new Set(
			(post.data.platforms ?? [])
				.map((platform) => classifyPlatformGroup(platform.name))
				.filter((group): group is PlatformFilterGroup => group !== null),
		),
	);

const formatMonthYear = (date: Date) =>
	date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });

const formatDate = (date: Date) =>
	date.toLocaleDateString('en-US', {
		year: 'numeric',
		month: 'short',
		day: 'numeric',
	});

const years = posts.map((post) => post.data.pubDate.getFullYear());
const latestYear = years.length ? Math.max(...years) : null;
const earliestYear = years.length ? Math.min(...years) : null;

const yearMap = new Map<number, RenderablePost[]>();
for (const post of archivePosts) {
	const year = post.data.pubDate.getFullYear();
	const list = yearMap.get(year) ?? [];
	list.push(post);
	yearMap.set(year, list);
}

const yearSections = Array.from(yearMap.entries())
	.sort((a, b) => b[0] - a[0])
	.map(([year, items]) => ({ year, items }));

const leadYearSection = yearSections[0];
const compactYearSections = yearSections.slice(1);

const genreCounts = new Map<string, number>();
const platformCounts = new Map<string, number>();

for (const post of posts) {
	for (const genre of post.data.genres ?? []) {
		genreCounts.set(genre, (genreCounts.get(genre) ?? 0) + 1);
	}
	for (const platformName of getFilterPlatforms(post)) {
		platformCounts.set(platformName, (platformCounts.get(platformName) ?? 0) + 1);
	}
}

const topGenres = Array.from(genreCounts.entries())
	.sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
	.slice(0, 6);
const topPlatforms = Array.from(platformCounts.entries())
	.sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0]))
	.slice(0, 6);
const maxGenreCount = Math.max(...topGenres.map(([, count]) => count), 1);

const filterGenres = topGenres.slice(0, 5).map(([name]) => name);
const filterPlatforms = PLATFORM_FILTER_GROUPS.filter((name) => platformCounts.has(name));
const filterYears = Array.from(new Set(years)).sort((a, b) => b - a).slice(0, 4);

const getCompactBadge = (post: RenderablePost) => {
	if (post.data.gotyYear) return { label: `${post.data.gotyYear} GOTY`, variant: 'goty' as const };
	if (post.data.draft) return { label: 'Draft', variant: 'draft' as const };
	return { label: 'Published', variant: 'pub' as const };
};

const token = (value: string) =>
	value
		.toLowerCase()
		.replace(/[^a-z0-9]+/g, '-')
		.replace(/^-+|-+$/g, '');

const postGenreTokens = (post: RenderablePost) => (post.data.genres ?? []).map(token).join(',');
const postPlatformTokens = (post: RenderablePost) => getFilterPlatforms(post).map(token).join(',');
---

<BaseLayout
	title={`Reviews | ${SITE_TITLE}`}
	description={SITE_DESCRIPTION}
	stylesheets={[reviewsIndexStylesHref]}
	mainClass="reviews-page"
>
			<section class="page-head">
				<div>
					<p class="page-eyebrow">{SITE_TITLE} / Archive</p>
					<h1 class="page-title">Reviews</h1>
					<p class="page-subtitle">
						One person's experience with the games she couldn't put down - or couldn't forgive.
					</p>
				</div>
				<div class="page-head-right">
					<span class="review-count">
						{posts.length} entries
						{latestYear && earliestYear && ` / ${earliestYear}-${latestYear}`}
					</span>
				</div>
			</section>

			<section class="filters-bar" aria-label="Review filters (display only)">
				<span class="filter-label">Filter</span>
				<button type="button" class="filter-btn active" data-filter-reset="true">All</button>
				{filterGenres.map((genre) => (
					<button type="button" class="filter-btn" data-filter-type="genre" data-filter-value={token(genre)}>
						{genre}
					</button>
				))}
				{filterPlatforms.length > 0 && <span class="filter-sep" aria-hidden="true"></span>}
				{filterPlatforms.map((platform) => (
					<button
						type="button"
						class="filter-btn"
						data-filter-type="platform"
						data-filter-value={token(platform)}
					>
						{platform}
					</button>
				))}
				{filterYears.length > 0 && <span class="filter-sep" aria-hidden="true"></span>}
				{filterYears.map((year) => (
					<button type="button" class="filter-btn" data-filter-type="year" data-filter-value={String(year)}>
						{year}
					</button>
				))}
				<div class="sort-group">
					<label for="reviews-sort" class="sort-label">Sort</label>
					<select id="reviews-sort" class="sort-select" data-sort-select>
						<option value="newest">Newest</option>
						<option value="oldest">Oldest</option>
					</select>
				</div>
			</section>

			<div class="reviews-layout">
				<div class="reviews-column">
					{
						featuredPosts.length > 0 && (
							<section class="featured" aria-label="Featured reviews" data-featured-wrap>
								<div class="featured-label">Featured</div>

								{featuredPosts[0] && (
									<a
										href={getPostHref(featuredPosts[0])}
										class="featured-card featured-card-hero"
										data-post-card
										data-featured-card
										data-mock={isMockPost(featuredPosts[0]) ? 'true' : undefined}
										data-date={featuredPosts[0].data.pubDate.toISOString()}
										data-year={featuredPosts[0].data.pubDate.getFullYear()}
										data-title={featuredPosts[0].data.title.toLowerCase()}
										data-genres={postGenreTokens(featuredPosts[0])}
										data-platforms={postPlatformTokens(featuredPosts[0])}
									>
										<div class="featured-media">
											{featuredPosts[0].data.heroImage ? (
												<Image
													width={1440}
													height={720}
													src={featuredPosts[0].data.heroImage}
													alt={featuredPosts[0].data.title}
													loading="eager"
													fetchpriority="high"
												/>
											) : (
												<div class="featured-card-image-placeholder" aria-hidden="true" />
											)}
										</div>
										<div class="featured-overlay" aria-hidden="true" />
										<div class="featured-content">
											<p class="featured-kicker">{getFeaturedKicker(featuredPosts[0])}</p>
											<h2 class="featured-title">{featuredPosts[0].data.title}</h2>
											<p class="featured-summary">
												{featuredPosts[0].data.blurb ?? featuredPosts[0].data.description}
											</p>
											<div class="featured-meta">
												{getPlayedPlatforms(featuredPosts[0]).map((platform) => (
													<span class="featured-pill">{platform}</span>
												))}
												<span class="featured-date">
													<time datetime={featuredPosts[0].data.pubDate.toISOString()}>
														{formatDate(featuredPosts[0].data.pubDate)}
													</time>
												</span>
											</div>
										</div>
									</a>
								)}

								{featuredPosts.length > 1 && (
									<div class="featured-subgrid" data-featured-subgrid>
										{featuredPosts.slice(1).map((post) => (
											<a
												href={getPostHref(post)}
												class="featured-card featured-card-tile"
												data-post-card
												data-featured-card
												data-mock={isMockPost(post) ? 'true' : undefined}
												data-date={post.data.pubDate.toISOString()}
												data-year={post.data.pubDate.getFullYear()}
												data-title={post.data.title.toLowerCase()}
												data-genres={postGenreTokens(post)}
												data-platforms={postPlatformTokens(post)}
											>
												<div class="featured-media">
													{post.data.heroImage ? (
														<Image width={720} height={420} src={post.data.heroImage} alt={post.data.title} />
													) : (
														<div class="featured-card-image-placeholder" aria-hidden="true" />
													)}
												</div>
												<div class="featured-overlay" aria-hidden="true" />
												<div class="featured-content">
													<p class="featured-kicker">{getFeaturedKicker(post)}</p>
													<h3 class="featured-title">{post.data.title}</h3>
													<div class="featured-meta">
														{getPreferredPlatform(post) && (
															<span class="featured-pill">{getPreferredPlatform(post)}</span>
														)}
														<span class="featured-date">{formatMonthYear(post.data.pubDate)}</span>
													</div>
												</div>
											</a>
										))}
									</div>
								)}
							</section>
						)
					}

					{
						leadYearSection && (
							<section
								class="year-section"
								aria-labelledby={`year-${leadYearSection.year}`}
								data-year-section
								data-year={leadYearSection.year}
							>
								<div class="section-heading">
									<span class="section-heading-text" id={`year-${leadYearSection.year}`}>
										{leadYearSection.year}
									</span>
									<div class="section-heading-line"></div>
								</div>

								<div class="article-grid article-grid-two-col">
									{leadYearSection.items.map((post) => (
										<a
											href={getPostHref(post)}
											class="article-card article-card-grid"
											data-post-card
											data-mock={isMockPost(post) ? 'true' : undefined}
											data-date={post.data.pubDate.toISOString()}
											data-year={post.data.pubDate.getFullYear()}
											data-title={post.data.title.toLowerCase()}
											data-genres={postGenreTokens(post)}
											data-platforms={postPlatformTokens(post)}
										>
											<div class="article-thumb">
												{post.data.heroImage ? (
													<Image width={640} height={360} src={post.data.heroImage} alt={post.data.title} />
												) : (
													<div class="review-card-image-placeholder" aria-hidden="true" />
												)}
											</div>
											<div class="article-info">
												<div class="article-genre">{getGenresLabel(post, 1)}</div>
												<h3 class="article-title">{post.data.title}</h3>
												<p class="article-excerpt">{post.data.blurb ?? post.data.description}</p>
												<div class="article-foot">
													<span class="article-date">
														<time datetime={post.data.pubDate.toISOString()}>
															{formatDate(post.data.pubDate)}
														</time>
													</span>
												</div>
											</div>
										</a>
									))}
								</div>
							</section>
						)
					}

					{
						compactYearSections.map((section) => (
							<section
								class="year-section"
								aria-labelledby={`year-${section.year}`}
								data-year-section
								data-year={section.year}
							>
								<div class="year-divider">
									<span class="year-num" id={`year-${section.year}`}>
										{section.year}
									</span>
									<div class="year-line"></div>
								</div>

								<div class="compact-list">
									{section.items.map((post, index) => {
										const badge = getCompactBadge(post);
										return (
											<a
												href={getPostHref(post)}
												class="compact-item"
												data-post-card
												data-mock={isMockPost(post) ? 'true' : undefined}
												data-date={post.data.pubDate.toISOString()}
												data-year={post.data.pubDate.getFullYear()}
												data-title={post.data.title.toLowerCase()}
												data-genres={postGenreTokens(post)}
												data-platforms={postPlatformTokens(post)}
											>
												<span class="compact-num">{String(index + 1).padStart(2, '0')}</span>
												<div class="compact-main">
													<div class="compact-title">{post.data.title}</div>
													<div class="compact-sub">
														{getGenresLabel(post, 1)}
														{` / ${formatMonthYear(post.data.pubDate)}`}
													</div>
												</div>
												<span class={`compact-badge badge-${badge.variant}`}>{badge.label}</span>
											</a>
										);
									})}
								</div>
							</section>
						))
					}

					{
						!leadYearSection && archivePosts.length === 0 && (
							<section class="empty-state">
								<p>No additional review entries yet.</p>
							</section>
						)
					}
				</div>

				<aside class="reviews-sidebar">
					<section class="sidebar-block">
						<div class="sidebar-header">
							<span class="sidebar-header-pip"></span>
							<span class="sidebar-header-text">Currently Playing</span>
						</div>
						<div class="now-list">
							{currentlyPlaying.map((game) => (
								<div class="now-item">
									<span class="now-pulse" aria-hidden="true"></span>
									<div>
										<div class="now-title">{game.title}</div>
										<div class="now-sub">
											{game.platform}
											{game.status && ` / ${game.status}`}
										</div>
									</div>
								</div>
							))}
						</div>
					</section>

					{topGenres.length > 0 && (
						<section class="sidebar-block">
							<div class="sidebar-header">
								<span class="sidebar-header-pip sidebar-header-pip-soft"></span>
								<span class="sidebar-header-text">By Genre</span>
							</div>
							<div class="genre-stack">
								{topGenres.map(([name, count]) => (
									<div class="genre-row">
										<div class="genre-item">
											<span class="genre-name">{name}</span>
											<span class="genre-count">{count}</span>
										</div>
										<div class="genre-bar-wrap" aria-hidden="true">
											<div class="genre-bar" style={`width: ${(count / maxGenreCount) * 100}%`}></div>
										</div>
									</div>
								))}
							</div>
						</section>
					)}

					{topPlatforms.length > 0 && (
						<section class="sidebar-block">
							<div class="sidebar-header">
								<span class="sidebar-header-pip sidebar-header-pip-soft"></span>
								<span class="sidebar-header-text">By Platform</span>
							</div>
							<div class="platform-grid">
								{topPlatforms.map(([name, count]) => (
									<div class="platform-item">
										<span class="platform-name">{name}</span>
										<span class="platform-count">{count}</span>
									</div>
								))}
							</div>
						</section>
					)}
				</aside>
			</div>
</BaseLayout>

<script is:inline>
	(function initReviewsFilters() {
		const filterButtons = Array.from(document.querySelectorAll('.filter-btn'));
		const resetButton = document.querySelector('[data-filter-reset="true"]');
		const sortSelect = document.querySelector('[data-sort-select]');
		const cards = Array.from(document.querySelectorAll('[data-post-card]'));
		const archiveCards = cards.filter((card) => !card.hasAttribute('data-featured-card'));
		const featuredWrap = document.querySelector('[data-featured-wrap]');
		const featuredSubgrid = document.querySelector('[data-featured-subgrid]');
		const yearSections = Array.from(document.querySelectorAll('[data-year-section]'));
		const reviewsColumn = document.querySelector('.reviews-column');

		if (!filterButtons.length || !reviewsColumn) return;

		const state = {
			genres: new Set(),
			platforms: new Set(),
			years: new Set(),
			sort: 'newest',
		};

		const parseSet = (value) => new Set((value || '').split(',').filter(Boolean));
		const compareText = (a, b) => a.localeCompare(b);
		const compareDate = (a, b) => new Date(a).getTime() - new Date(b).getTime();

		const matches = (card) => {
			const year = card.dataset.year || '';
			const genres = parseSet(card.dataset.genres);
			const platforms = parseSet(card.dataset.platforms);

			if (state.years.size && !state.years.has(year)) return false;
			if (state.genres.size && ![...state.genres].some((g) => [...genres].some((gt) => gt.includes(g)))) return false;
			if (state.platforms.size && ![...state.platforms].some((p) => platforms.has(p))) return false;
			return true;
		};

		const syncResetState = () => {
			const hasFilters = state.genres.size || state.platforms.size || state.years.size;
			resetButton?.classList.toggle('active', !hasFilters);
		};

		const sortYearSections = () => {
			const sortedSections = [...yearSections].sort((a, b) => {
				const ay = Number(a.dataset.year || '0');
				const by = Number(b.dataset.year || '0');
				return state.sort === 'oldest' ? ay - by : by - ay;
			});
			sortedSections.forEach((section) => reviewsColumn.appendChild(section));

			yearSections.forEach((section) => {
				const list = section.querySelector('.article-grid, .compact-list');
				if (!list) return;
				const sectionCards = Array.from(list.querySelectorAll('[data-post-card]'));
				sectionCards.sort((a, b) => {
					const dateCmp = compareDate(a.dataset.date || '', b.dataset.date || '');
					if (dateCmp !== 0) return state.sort === 'oldest' ? dateCmp : -dateCmp;
					return compareText(a.dataset.title || '', b.dataset.title || '');
				});
				sectionCards.forEach((card) => list.appendChild(card));
			});
		};

		const updateVisibility = () => {
			archiveCards.forEach((card) => {
				card.hidden = !matches(card);
			});

			yearSections.forEach((section) => {
				const visibleCards = Array.from(section.querySelectorAll('[data-post-card]')).filter((card) => !card.hidden);
				section.hidden = visibleCards.length === 0;
			});
		};

		const apply = () => {
			syncResetState();
			sortYearSections();
			updateVisibility();
		};

		filterButtons.forEach((button) => {
			button.addEventListener('click', () => {
				if (button.hasAttribute('data-filter-reset')) {
					state.genres.clear();
					state.platforms.clear();
					state.years.clear();
					filterButtons.forEach((btn) => {
						if (!btn.hasAttribute('data-filter-reset')) btn.classList.remove('active');
					});
					apply();
					return;
				}

				const type = button.dataset.filterType;
				const value = button.dataset.filterValue;
				if (!type || !value) return;

				const map = type === 'genre' ? state.genres : type === 'platform' ? state.platforms : state.years;

				if (type === 'platform') {
					const wasActive = map.has(value);
					map.clear();
					filterButtons.forEach((btn) => {
						if (btn.dataset.filterType === 'platform') btn.classList.remove('active');
					});
					if (!wasActive) {
						map.add(value);
						button.classList.add('active');
					}
					apply();
					return;
				}

				if (map.has(value)) {
					map.delete(value);
					button.classList.remove('active');
				} else {
					map.add(value);
					button.classList.add('active');
				}

				apply();
			});
		});

		sortSelect?.addEventListener('change', (event) => {
			state.sort = event.target.value === 'oldest' ? 'oldest' : 'newest';
			apply();
		});

		apply();
	})();
</script>
